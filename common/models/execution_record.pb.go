// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tiops/common/models/execution_record.proto

package models

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ProcessRecord struct {
	RecordTime           int64    `protobuf:"varint,1,opt,name=recordTime,proto3" json:"recordTime,omitempty" bson:"recordTime"`
	StartTime            int64    `protobuf:"varint,2,opt,name=startTime,proto3" json:"startTime,omitempty" bson:"startTime"`
	EndTime              int64    `protobuf:"varint,3,opt,name=endTime,proto3" json:"endTime,omitempty" bson:"endTime"`
	NodeId               string   `protobuf:"bytes,4,opt,name=nodeId,proto3" json:"nodeId,omitempty" bson:"nodeId"`
	ActionName           string   `protobuf:"bytes,5,opt,name=actionName,proto3" json:"actionName,omitempty" bson:"actionName"`
	ItemCount            int32    `protobuf:"varint,6,opt,name=itemCount,proto3" json:"itemCount,omitempty" bson:"itemCount"`
	BatchCount           int32    `protobuf:"varint,7,opt,name=batchCount,proto3" json:"batchCount,omitempty" bson:"batchCount"`
	ElapsedTime          int32    `protobuf:"varint,8,opt,name=elapsedTime,proto3" json:"elapsedTime,omitempty" bson:"elapsedTime"`
	ProcessRate          float32  `protobuf:"fixed32,9,opt,name=processRate,proto3" json:"processRate,omitempty" bson:"processRate"`
	BacklogBatches       int32    `protobuf:"varint,10,opt,name=backlogBatches,proto3" json:"backlogBatches,omitempty" bson:"backlogBatches"`
	BatchSize            int32    `protobuf:"varint,14,opt,name=batchSize,proto3" json:"batchSize,omitempty" bson:"batchSize"`
	RecordId             string   `protobuf:"bytes,15,opt,name=recordId,proto3" json:"recordId,omitempty" bson:"recordId"`
	ExecutionId          string   `protobuf:"bytes,16,opt,name=executionId,proto3" json:"executionId,omitempty" bson:"executionId"`
	DataIds              []string `protobuf:"bytes,17,rep,name=dataIds,proto3" json:"dataIds,omitempty" bson:"dataIds"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" bson:"-"`
	XXX_unrecognized     []byte   `json:"-" bson:"-"`
	XXX_sizecache        int32    `json:"-" bson:"-"`
}

func (m *ProcessRecord) Reset()         { *m = ProcessRecord{} }
func (m *ProcessRecord) String() string { return proto.CompactTextString(m) }
func (*ProcessRecord) ProtoMessage()    {}
func (*ProcessRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e19eb825fb4b0ee, []int{0}
}
func (m *ProcessRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessRecord.Merge(m, src)
}
func (m *ProcessRecord) XXX_Size() int {
	return m.Size()
}
func (m *ProcessRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessRecord.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessRecord proto.InternalMessageInfo

func (m *ProcessRecord) GetRecordTime() int64 {
	if m != nil {
		return m.RecordTime
	}
	return 0
}

func (m *ProcessRecord) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *ProcessRecord) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *ProcessRecord) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *ProcessRecord) GetActionName() string {
	if m != nil {
		return m.ActionName
	}
	return ""
}

func (m *ProcessRecord) GetItemCount() int32 {
	if m != nil {
		return m.ItemCount
	}
	return 0
}

func (m *ProcessRecord) GetBatchCount() int32 {
	if m != nil {
		return m.BatchCount
	}
	return 0
}

func (m *ProcessRecord) GetElapsedTime() int32 {
	if m != nil {
		return m.ElapsedTime
	}
	return 0
}

func (m *ProcessRecord) GetProcessRate() float32 {
	if m != nil {
		return m.ProcessRate
	}
	return 0
}

func (m *ProcessRecord) GetBacklogBatches() int32 {
	if m != nil {
		return m.BacklogBatches
	}
	return 0
}

func (m *ProcessRecord) GetBatchSize() int32 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

func (m *ProcessRecord) GetRecordId() string {
	if m != nil {
		return m.RecordId
	}
	return ""
}

func (m *ProcessRecord) GetExecutionId() string {
	if m != nil {
		return m.ExecutionId
	}
	return ""
}

func (m *ProcessRecord) GetDataIds() []string {
	if m != nil {
		return m.DataIds
	}
	return nil
}

type ExecutionRecord struct {
	XId                  string           `protobuf:"bytes,1,opt,name=_id,json=Id,proto3" json:"_id,omitempty" bson:"_id"`
	ExecutionId          string           `protobuf:"bytes,2,opt,name=executionId,proto3" json:"executionId,omitempty" bson:"executionId"`
	ProcessRecords       []*ProcessRecord `protobuf:"bytes,3,rep,name=processRecords,proto3" json:"processRecords,omitempty" bson:"processRecords"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-" bson:"-"`
	XXX_unrecognized     []byte           `json:"-" bson:"-"`
	XXX_sizecache        int32            `json:"-" bson:"-"`
}

func (m *ExecutionRecord) Reset()         { *m = ExecutionRecord{} }
func (m *ExecutionRecord) String() string { return proto.CompactTextString(m) }
func (*ExecutionRecord) ProtoMessage()    {}
func (*ExecutionRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_2e19eb825fb4b0ee, []int{1}
}
func (m *ExecutionRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutionRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutionRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutionRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutionRecord.Merge(m, src)
}
func (m *ExecutionRecord) XXX_Size() int {
	return m.Size()
}
func (m *ExecutionRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutionRecord.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutionRecord proto.InternalMessageInfo

func (m *ExecutionRecord) GetXId() string {
	if m != nil {
		return m.XId
	}
	return ""
}

func (m *ExecutionRecord) GetExecutionId() string {
	if m != nil {
		return m.ExecutionId
	}
	return ""
}

func (m *ExecutionRecord) GetProcessRecords() []*ProcessRecord {
	if m != nil {
		return m.ProcessRecords
	}
	return nil
}

func init() {
	proto.RegisterType((*ProcessRecord)(nil), "models.ProcessRecord")
	proto.RegisterType((*ExecutionRecord)(nil), "models.ExecutionRecord")
}

func init() {
	proto.RegisterFile("tiops/common/models/execution_record.proto", fileDescriptor_2e19eb825fb4b0ee)
}

var fileDescriptor_2e19eb825fb4b0ee = []byte{
	// 421 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x52, 0x4d, 0x8b, 0x14, 0x31,
	0x10, 0x35, 0x13, 0x77, 0x76, 0xbb, 0x16, 0x67, 0x34, 0xe0, 0x12, 0x16, 0x69, 0xc2, 0x1c, 0xa4,
	0xf1, 0xd0, 0x03, 0x7a, 0x13, 0xbc, 0x8c, 0x78, 0x98, 0x8b, 0x48, 0xf4, 0x3e, 0x64, 0x3a, 0xc5,
	0x18, 0x9c, 0xee, 0x34, 0x9d, 0x2c, 0x88, 0x67, 0x7f, 0x82, 0x07, 0xf1, 0xe0, 0x5f, 0xf1, 0xea,
	0xd1, 0x9f, 0x20, 0xe3, 0x1f, 0x91, 0x24, 0xdd, 0xbb, 0xbd, 0x1f, 0xc7, 0x7a, 0xef, 0xa5, 0x5e,
	0xa5, 0xea, 0xc1, 0x33, 0x6f, 0x6c, 0xeb, 0x96, 0x95, 0xad, 0x6b, 0xdb, 0x2c, 0x6b, 0xab, 0x71,
	0xef, 0x96, 0xf8, 0x19, 0xab, 0x0b, 0x6f, 0x6c, 0xb3, 0xe9, 0xb0, 0xb2, 0x9d, 0x2e, 0xdb, 0xce,
	0x7a, 0xcb, 0xa6, 0x89, 0x3e, 0x17, 0x77, 0xbd, 0x49, 0x55, 0x52, 0xde, 0xad, 0xf0, 0x6a, 0xb7,
	0xc3, 0x2e, 0x29, 0x16, 0xbf, 0x28, 0x3c, 0x78, 0xd7, 0xd9, 0x0a, 0x9d, 0x93, 0xd1, 0x83, 0xe5,
	0x00, 0xc9, 0xed, 0x83, 0xa9, 0x91, 0x13, 0x41, 0x0a, 0x2a, 0x47, 0x08, 0x7b, 0x02, 0x99, 0xf3,
	0xaa, 0xf3, 0x91, 0x9e, 0x44, 0xfa, 0x0a, 0x60, 0x1c, 0x8e, 0xb1, 0x49, 0x4f, 0x69, 0xe4, 0x86,
	0x92, 0x9d, 0xc1, 0xb4, 0xb1, 0x1a, 0xd7, 0x9a, 0xdf, 0x17, 0xa4, 0xc8, 0x64, 0x5f, 0x05, 0x3f,
	0x55, 0x85, 0x4f, 0xbe, 0x55, 0x35, 0xf2, 0xa3, 0xc8, 0x8d, 0x90, 0xe0, 0x67, 0x3c, 0xd6, 0xaf,
	0xed, 0x45, 0xe3, 0xf9, 0x54, 0x90, 0xe2, 0x48, 0x5e, 0x01, 0xe1, 0xf5, 0x56, 0xf9, 0xea, 0x63,
	0xa2, 0x8f, 0x23, 0x3d, 0x42, 0x98, 0x80, 0x53, 0xdc, 0xab, 0xd6, 0x61, 0x9a, 0xe9, 0x24, 0x0a,
	0xc6, 0x50, 0x50, 0xb4, 0xfd, 0x02, 0x94, 0x47, 0x9e, 0x09, 0x52, 0x4c, 0xe4, 0x18, 0x62, 0x4f,
	0x61, 0xb6, 0x55, 0xd5, 0xa7, 0xbd, 0xdd, 0xad, 0x42, 0x63, 0x74, 0x1c, 0x62, 0x9b, 0x1b, 0x68,
	0x98, 0x34, 0x3a, 0xbf, 0x37, 0x5f, 0x90, 0xcf, 0xd2, 0xa4, 0x97, 0x00, 0x3b, 0x87, 0x93, 0xb4,
	0xc5, 0xb5, 0xe6, 0xf3, 0xf8, 0xcb, 0xcb, 0x3a, 0x4e, 0x39, 0xdc, 0x7a, 0xad, 0xf9, 0xc3, 0x48,
	0x8f, 0xa1, 0xb0, 0x57, 0xad, 0xbc, 0x5a, 0x6b, 0xc7, 0x1f, 0x09, 0x5a, 0x64, 0x72, 0x28, 0x17,
	0xdf, 0x08, 0xcc, 0xdf, 0x0c, 0xca, 0xfe, 0x86, 0x02, 0xe8, 0xc6, 0xe8, 0x78, 0xbc, 0x6c, 0x35,
	0xff, 0xf1, 0xf5, 0x27, 0x85, 0xad, 0xb3, 0xcd, 0xcb, 0xc5, 0xc6, 0xe8, 0x85, 0x9c, 0xdc, 0x76,
	0x9c, 0xdc, 0x76, 0x7c, 0x05, 0xb3, 0x76, 0x1c, 0x0c, 0xc7, 0xa9, 0xa0, 0xc5, 0xe9, 0xf3, 0xc7,
	0x65, 0xca, 0x51, 0x79, 0x2d, 0x36, 0xf2, 0x86, 0x78, 0x55, 0xfc, 0x3e, 0xe4, 0xe4, 0xcf, 0x21,
	0x27, 0x7f, 0x0f, 0x39, 0xf9, 0xfe, 0x2f, 0xbf, 0x07, 0x67, 0xc6, 0x96, 0x31, 0x8f, 0x65, 0x9f,
	0xd1, 0xd4, 0x67, 0x3b, 0x8d, 0x49, 0x7c, 0xf1, 0x3f, 0x00, 0x00, 0xff, 0xff, 0x8e, 0x39, 0xc3,
	0x52, 0x03, 0x03, 0x00, 0x00,
}

func (m *ProcessRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DataIds) > 0 {
		for iNdEx := len(m.DataIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DataIds[iNdEx])
			copy(dAtA[i:], m.DataIds[iNdEx])
			i = encodeVarintExecutionRecord(dAtA, i, uint64(len(m.DataIds[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.ExecutionId) > 0 {
		i -= len(m.ExecutionId)
		copy(dAtA[i:], m.ExecutionId)
		i = encodeVarintExecutionRecord(dAtA, i, uint64(len(m.ExecutionId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.RecordId) > 0 {
		i -= len(m.RecordId)
		copy(dAtA[i:], m.RecordId)
		i = encodeVarintExecutionRecord(dAtA, i, uint64(len(m.RecordId)))
		i--
		dAtA[i] = 0x7a
	}
	if m.BatchSize != 0 {
		i = encodeVarintExecutionRecord(dAtA, i, uint64(m.BatchSize))
		i--
		dAtA[i] = 0x70
	}
	if m.BacklogBatches != 0 {
		i = encodeVarintExecutionRecord(dAtA, i, uint64(m.BacklogBatches))
		i--
		dAtA[i] = 0x50
	}
	if m.ProcessRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ProcessRate))))
		i--
		dAtA[i] = 0x4d
	}
	if m.ElapsedTime != 0 {
		i = encodeVarintExecutionRecord(dAtA, i, uint64(m.ElapsedTime))
		i--
		dAtA[i] = 0x40
	}
	if m.BatchCount != 0 {
		i = encodeVarintExecutionRecord(dAtA, i, uint64(m.BatchCount))
		i--
		dAtA[i] = 0x38
	}
	if m.ItemCount != 0 {
		i = encodeVarintExecutionRecord(dAtA, i, uint64(m.ItemCount))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ActionName) > 0 {
		i -= len(m.ActionName)
		copy(dAtA[i:], m.ActionName)
		i = encodeVarintExecutionRecord(dAtA, i, uint64(len(m.ActionName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintExecutionRecord(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0x22
	}
	if m.EndTime != 0 {
		i = encodeVarintExecutionRecord(dAtA, i, uint64(m.EndTime))
		i--
		dAtA[i] = 0x18
	}
	if m.StartTime != 0 {
		i = encodeVarintExecutionRecord(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x10
	}
	if m.RecordTime != 0 {
		i = encodeVarintExecutionRecord(dAtA, i, uint64(m.RecordTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExecutionRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutionRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutionRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProcessRecords) > 0 {
		for iNdEx := len(m.ProcessRecords) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProcessRecords[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutionRecord(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ExecutionId) > 0 {
		i -= len(m.ExecutionId)
		copy(dAtA[i:], m.ExecutionId)
		i = encodeVarintExecutionRecord(dAtA, i, uint64(len(m.ExecutionId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.XId) > 0 {
		i -= len(m.XId)
		copy(dAtA[i:], m.XId)
		i = encodeVarintExecutionRecord(dAtA, i, uint64(len(m.XId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintExecutionRecord(dAtA []byte, offset int, v uint64) int {
	offset -= sovExecutionRecord(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ProcessRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RecordTime != 0 {
		n += 1 + sovExecutionRecord(uint64(m.RecordTime))
	}
	if m.StartTime != 0 {
		n += 1 + sovExecutionRecord(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovExecutionRecord(uint64(m.EndTime))
	}
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovExecutionRecord(uint64(l))
	}
	l = len(m.ActionName)
	if l > 0 {
		n += 1 + l + sovExecutionRecord(uint64(l))
	}
	if m.ItemCount != 0 {
		n += 1 + sovExecutionRecord(uint64(m.ItemCount))
	}
	if m.BatchCount != 0 {
		n += 1 + sovExecutionRecord(uint64(m.BatchCount))
	}
	if m.ElapsedTime != 0 {
		n += 1 + sovExecutionRecord(uint64(m.ElapsedTime))
	}
	if m.ProcessRate != 0 {
		n += 5
	}
	if m.BacklogBatches != 0 {
		n += 1 + sovExecutionRecord(uint64(m.BacklogBatches))
	}
	if m.BatchSize != 0 {
		n += 1 + sovExecutionRecord(uint64(m.BatchSize))
	}
	l = len(m.RecordId)
	if l > 0 {
		n += 1 + l + sovExecutionRecord(uint64(l))
	}
	l = len(m.ExecutionId)
	if l > 0 {
		n += 2 + l + sovExecutionRecord(uint64(l))
	}
	if len(m.DataIds) > 0 {
		for _, s := range m.DataIds {
			l = len(s)
			n += 2 + l + sovExecutionRecord(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecutionRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.XId)
	if l > 0 {
		n += 1 + l + sovExecutionRecord(uint64(l))
	}
	l = len(m.ExecutionId)
	if l > 0 {
		n += 1 + l + sovExecutionRecord(uint64(l))
	}
	if len(m.ProcessRecords) > 0 {
		for _, e := range m.ProcessRecords {
			l = e.Size()
			n += 1 + l + sovExecutionRecord(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovExecutionRecord(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozExecutionRecord(x uint64) (n int) {
	return sovExecutionRecord(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ProcessRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutionRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordTime", wireType)
			}
			m.RecordTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutionRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutionRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutionRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutionRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutionRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutionRecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutionRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutionRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutionRecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemCount", wireType)
			}
			m.ItemCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutionRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchCount", wireType)
			}
			m.BatchCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutionRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElapsedTime", wireType)
			}
			m.ElapsedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutionRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElapsedTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ProcessRate = float32(math.Float32frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BacklogBatches", wireType)
			}
			m.BacklogBatches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutionRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BacklogBatches |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSize", wireType)
			}
			m.BatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutionRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutionRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutionRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutionRecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutionRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutionRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutionRecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutionRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutionRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutionRecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataIds = append(m.DataIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutionRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutionRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutionRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutionRecord
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutionRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutionRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutionRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutionRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutionRecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutionRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutionRecord
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutionRecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessRecords", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutionRecord
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutionRecord
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutionRecord
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcessRecords = append(m.ProcessRecords, &ProcessRecord{})
			if err := m.ProcessRecords[len(m.ProcessRecords)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutionRecord(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutionRecord
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipExecutionRecord(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowExecutionRecord
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExecutionRecord
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExecutionRecord
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthExecutionRecord
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupExecutionRecord
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthExecutionRecord
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthExecutionRecord        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowExecutionRecord          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupExecutionRecord = fmt.Errorf("proto: unexpected end of group")
)
